<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DOGMA Studios - Redefining Browser Gaming</title>
    <meta name="description" content="DOGMA Studios - Building the next WebGPU-native game engine. 1,000+ players per region. 144 FPS. Zero downloads.">
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;500;600;700;800;900&family=Cormorant:wght@300;400;500;600&family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #050a12;
            color: #fff;
            overflow-x: hidden;
        }

        /* Stats badge - FIXED to top */
        .stats-badge {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            background: rgba(5, 10, 18, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(88, 180, 209, 0.2);
            padding: 12px 16px;
            border-radius: 8px;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 0.65rem;
            line-height: 1.7;
            color: rgba(255, 255, 255, 0.5);
        }

        .stats-badge .highlight {
            color: #58b4d1;
            font-weight: 600;
        }

        .stats-badge .status-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .stats-badge .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #4ade80;
            box-shadow: 0 0 10px rgba(74, 222, 128, 0.6);
            animation: statusPulse 2s ease-in-out infinite;
        }

        .stats-badge .status-dot.inactive {
            background: #f87171;
            box-shadow: 0 0 10px rgba(248, 113, 113, 0.6);
            animation: none;
        }

        .stats-badge .status-text {
            color: #4ade80;
            font-weight: 600;
        }

        .stats-badge .status-text.inactive {
            color: #f87171;
        }

        @keyframes statusPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* ========== HERO WITH WEBGPU ========== */
        .hero {
            position: relative;
            height: 100vh;
            min-height: 700px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        #hero-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .hero-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 200px;
            background: linear-gradient(to bottom, transparent, #050a12);
            z-index: 5;
            pointer-events: none;
        }

        .heaven-glow {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 100%;
            height: 200px;
            background: radial-gradient(ellipse 50% 100% at 50% 0%, 
                rgba(212, 175, 55, 0.15) 0%,
                rgba(180, 140, 30, 0.05) 40%,
                transparent 70%
            );
            z-index: 5;
            pointer-events: none;
        }

        .golden-bar {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 2px;
            height: 70px;
            background: linear-gradient(180deg,
                rgba(212, 175, 55, 0.9) 0%,
                rgba(212, 175, 55, 0.3) 60%,
                transparent 100%
            );
            z-index: 6;
            animation: pulse 3s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }

        /* Text backdrop for better readability */
        .text-backdrop {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            height: 450px;
            background: radial-gradient(ellipse 45% 70% at 50% 50%,
                rgba(5, 10, 18, 0.75) 0%,
                rgba(5, 10, 18, 0.4) 50%,
                transparent 85%
            );
            z-index: 8;
            pointer-events: none;
        }

        .hero-content {
            position: relative;
            z-index: 10;
            text-align: center;
            padding: 0 20px;
        }

        /* DOGMA - Bold, dimensional, blue with subtle glow */
        .logo-text {
            font-family: 'Cinzel', serif;
            font-weight: 800;
            font-size: clamp(3.5rem, 12vw, 9rem);
            letter-spacing: 0.28em;
            text-indent: 0.28em;
            line-height: 1.1;
            
            /* Rich blue gradient */
            background: linear-gradient(
                180deg,
                #7ec8e3 0%,
                #5ab4d4 30%,
                #3a9fc4 50%,
                #5ab4d4 70%,
                #7ec8e3 100%
            );
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            
            /* Layered shadows for depth + soft glow */
            filter: 
                drop-shadow(0 0 1px rgba(90, 180, 212, 0.9))
                drop-shadow(0 0 2px rgba(90, 180, 212, 0.6))
                drop-shadow(0 2px 4px rgba(0, 0, 0, 0.8))
                drop-shadow(0 4px 8px rgba(0, 0, 0, 0.6))
                drop-shadow(0 0 30px rgba(90, 180, 212, 0.25));
        }

        /* STUDIOS - Gold accent, matching presence */
        .studios-text {
            font-family: 'Cinzel', serif;
            font-weight: 600;
            font-size: clamp(1.1rem, 3vw, 1.8rem);
            letter-spacing: 0.55em;
            text-indent: 0.55em;
            background: linear-gradient(
                180deg,
                #e8d48a 0%,
                #d4af37 50%,
                #e8d48a 100%
            );
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-top: 15px;
            filter: 
                drop-shadow(0 0 1px rgba(212, 175, 55, 0.8))
                drop-shadow(0 2px 4px rgba(0, 0, 0, 0.7))
                drop-shadow(0 0 20px rgba(212, 175, 55, 0.2));
        }

        /* Tagline - Elegant, readable */
        .hero-tagline {
            font-family: 'Cormorant', serif;
            font-size: clamp(1.2rem, 3vw, 1.7rem);
            font-weight: 600;
            color: #a8d4e6;
            margin-top: 50px;
            font-style: italic;
            letter-spacing: 0.12em;
            text-shadow: 
                0 0 1px rgba(168, 212, 230, 0.6),
                0 2px 8px rgba(0, 0, 0, 0.8),
                0 0 25px rgba(90, 180, 212, 0.15);
        }

        .scroll-indicator {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            opacity: 0.5;
            animation: bounce 2s ease-in-out infinite;
        }

        .scroll-indicator span {
            font-size: 0.7rem;
            letter-spacing: 0.15em;
            color: rgba(255,255,255,0.5);
        }

        .scroll-indicator svg {
            width: 24px;
            height: 24px;
            stroke: rgba(255,255,255,0.5);
        }

        @keyframes bounce {
            0%, 100% { transform: translateX(-50%) translateY(0); }
            50% { transform: translateX(-50%) translateY(8px); }
        }

        /* ========== MAIN CONTENT ========== */
        .main-content {
            position: relative;
            z-index: 5;
            background: #050a12;
        }

        section {
            padding: 100px 20px;
            max-width: 1100px;
            margin: 0 auto;
        }

        /* About section */
        .about-section {
            text-align: center;
        }

        .section-label {
            font-size: 0.75rem;
            letter-spacing: 0.25em;
            color: rgba(212, 175, 55, 0.6);
            text-transform: uppercase;
            margin-bottom: 20px;
        }

        .section-title {
            font-family: 'Cinzel', serif;
            font-size: clamp(1.8rem, 4vw, 2.8rem);
            font-weight: 500;
            margin-bottom: 30px;
            background: linear-gradient(135deg, #fff 0%, #8ecae6 100%);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .about-text {
            font-size: 1.15rem;
            line-height: 1.9;
            color: rgba(255, 255, 255, 0.75);
            max-width: 800px;
            margin: 0 auto;
            font-weight: 300;
        }

        .about-text .highlight {
            color: #58b4d1;
            font-weight: 500;
        }

        .about-text .highlight-gold {
            color: #d4af37;
            font-weight: 500;
        }

        /* Stats section */
        .stats-section {
            background: linear-gradient(180deg, transparent 0%, rgba(88, 180, 209, 0.03) 50%, transparent 100%);
            padding: 80px 20px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 30px;
            max-width: 1000px;
            margin: 0 auto;
        }

        .stat-card {
            text-align: center;
            padding: 40px 20px;
            background: rgba(10, 25, 45, 0.5);
            border: 1px solid rgba(88, 180, 209, 0.1);
            border-radius: 16px;
            transition: all 0.4s ease;
            position: relative;
            overflow: hidden;
        }

        .stat-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, rgba(88, 180, 209, 0.4), transparent);
            opacity: 0;
            transition: opacity 0.4s ease;
        }

        .stat-card:hover {
            transform: translateY(-5px);
            border-color: rgba(88, 180, 209, 0.25);
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.3);
        }

        .stat-card:hover::before {
            opacity: 1;
        }

        .stat-value {
            font-family: 'Cinzel', serif;
            font-size: 2.8rem;
            font-weight: 600;
            background: linear-gradient(180deg, #8ecae6, #58b4d1);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 12px;
        }

        .stat-label {
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.5);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        /* Dogmas section */
        .dogmas-section {
            padding: 120px 20px;
        }

        .dogmas-header {
            text-align: center;
            margin-bottom: 60px;
        }

        .dogmas-grid {
            display: flex;
            flex-direction: column;
            gap: 16px;
            max-width: 900px;
            margin: 0 auto;
        }

        .dogma-card {
            display: grid;
            grid-template-columns: 1fr 50px 1fr;
            align-items: center;
            padding: 28px 35px;
            background: rgba(10, 25, 45, 0.4);
            border: 1px solid rgba(88, 180, 209, 0.08);
            border-radius: 12px;
            transition: all 0.3s ease;
        }

        .dogma-card:hover {
            background: rgba(10, 25, 45, 0.6);
            border-color: rgba(88, 180, 209, 0.2);
            transform: translateX(10px);
        }

        .dogma-old {
            text-align: right;
            color: rgba(255, 255, 255, 0.35);
            font-size: 0.95rem;
            text-decoration: line-through;
            font-style: italic;
        }

        .dogma-arrow {
            text-align: center;
            color: #d4af37;
            font-size: 1.4rem;
        }

        .dogma-new {
            color: rgba(255, 255, 255, 0.9);
            font-size: 1rem;
            font-weight: 500;
        }

        /* CTA section */
        .cta-section {
            text-align: center;
            padding: 120px 20px;
            position: relative;
        }

        .cta-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 1px;
            height: 80px;
            background: linear-gradient(180deg, transparent, rgba(88, 180, 209, 0.3), transparent);
        }

        .cta-title {
            font-family: 'Cinzel', serif;
            font-size: clamp(1.5rem, 3vw, 2.2rem);
            font-weight: 500;
            margin-bottom: 20px;
            color: rgba(255, 255, 255, 0.9);
        }

        .cta-subtitle {
            color: rgba(255, 255, 255, 0.5);
            margin-bottom: 40px;
            font-size: 1rem;
        }

        .cta-button {
            display: inline-block;
            padding: 18px 50px;
            background: transparent;
            border: 1px solid rgba(212, 175, 55, 0.4);
            border-radius: 100px;
            color: #d4af37;
            text-decoration: none;
            font-family: 'Cinzel', serif;
            font-size: 0.95rem;
            font-weight: 500;
            letter-spacing: 0.12em;
            transition: all 0.3s ease;
        }

        .cta-button:hover {
            background: rgba(212, 175, 55, 0.1);
            border-color: rgba(212, 175, 55, 0.7);
            box-shadow: 0 0 40px rgba(212, 175, 55, 0.15);
            transform: translateY(-3px);
        }

        /* Footer */
        footer {
            text-align: center;
            padding: 60px 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.05);
        }

        .footer-copy {
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.25);
            letter-spacing: 0.05em;
        }

        /* Mobile */
        @media (max-width: 900px) {
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 768px) {
            .hero {
                min-height: 600px;
            }

            .stats-badge {
                top: 10px;
                left: 10px;
                padding: 10px 12px;
                font-size: 0.6rem;
            }

            section {
                padding: 70px 20px;
            }

            .stats-grid {
                gap: 15px;
            }

            .stat-card {
                padding: 25px 15px;
            }

            .stat-value {
                font-size: 2rem;
            }

            .dogma-card {
                grid-template-columns: 1fr;
                text-align: center;
                gap: 15px;
                padding: 25px;
            }

            .dogma-old, .dogma-new {
                text-align: center !important;
            }

            .dogma-arrow {
                transform: rotate(90deg);
            }

            .scroll-indicator {
                display: none;
            }
        }

        @media (max-width: 500px) {
            .stats-grid {
                grid-template-columns: 1fr 1fr;
            }
        }
    </style>
</head>
<body>

    <!-- Stats badge - FIXED position, stays on scroll -->
    <div class="stats-badge" id="stats-badge">
        <div class="status-row">
            <div class="status-dot" id="status-dot"></div>
            <span class="status-text" id="status-text">Detecting...</span>
        </div>
        <div>Particles: <span class="highlight" id="particle-count">—</span></div>
        <div>FPS: <span class="highlight" id="fps-display">—</span></div>
    </div>

    <!-- ========== HERO WITH WEBGPU ========== -->
    <header class="hero">
        <canvas id="hero-canvas"></canvas>
        
        <!-- Text backdrop for readability -->
        <div class="text-backdrop"></div>
        
        <div class="heaven-glow"></div>
        <div class="golden-bar"></div>
        <div class="hero-overlay"></div>

        <div class="hero-content">
            <h1 class="logo-text">DOGMA</h1>
            <p class="studios-text">STUDIOS</p>
            <p class="hero-tagline">Redefining Browser Gaming</p>
        </div>

        <div class="scroll-indicator">
            <span>Scroll</span>
            <svg viewBox="0 0 24 24" fill="none" stroke-width="2">
                <path d="M12 5v14M5 12l7 7 7-7"/>
            </svg>
        </div>
    </header>

    <!-- ========== MAIN CONTENT ========== -->
    <main class="main-content">

        <!-- About -->
        <section class="about-section">
            <p class="section-label">The Vision</p>
            <h2 class="section-title">The Future of Gaming is Browser-Native</h2>
            <p class="about-text">
                We're building the <span class="highlight">WebGPU-native game engine</span> that gives 
                desktop clients a run for their money. <span class="highlight-gold">True WebGPU architecture</span> with edge computing.
                Thousands of players per region, seamless global scale. Zero downloads. Instant play.
            </p>
        </section>

        <!-- Stats -->
        <section class="stats-section">
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value">1,000+</div>
                    <div class="stat-label">Players Per Region</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">144</div>
                    <div class="stat-label">FPS Target</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">0MB</div>
                    <div class="stat-label">Download Size</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">&lt;15ms</div>
                    <div class="stat-label">Edge Latency</div>
                </div>
            </div>
        </section>

        <!-- Dogmas -->
        <section class="dogmas-section">
            <div class="dogmas-header">
                <p class="section-label">Breaking Boundaries</p>
                <h2 class="section-title">Shattering Industry Dogmas</h2>
            </div>
            
            <div class="dogmas-grid">
                <div class="dogma-card">
                    <span class="dogma-old">"Browser games can't match native MMO architecture"</span>
                    <span class="dogma-arrow">→</span>
                    <span class="dogma-new">1,000/region, seamless global scale, no loading screens</span>
                </div>
                <div class="dogma-card">
                    <span class="dogma-old">"JavaScript is too slow for games"</span>
                    <span class="dogma-arrow">→</span>
                    <span class="dogma-new">GPU compute + WASM = native performance</span>
                </div>
                <div class="dogma-card">
                    <span class="dogma-old">"Players need to download clients"</span>
                    <span class="dogma-arrow">→</span>
                    <span class="dogma-new">Edge computing + streaming: instant play, zero friction</span>
                </div>
            </div>
        </section>

        <!-- CTA -->
        <section class="cta-section">
            <h2 class="cta-title">Ready to Build the Future?</h2>
            <p class="cta-subtitle">Let's talk about what's next for browser gaming.</p>
            <a href="mailto:austin@dogma.game" class="cta-button">Get In Touch</a>
        </section>

    </main>

    <!-- Footer -->
    <footer>
        <p class="footer-copy">© 2025 DOGMA Studios. All rights reserved.</p>
    </footer>

    <!-- ========== WEBGPU SCRIPT ========== -->
    <script>
    const NUM_PARTICLES = 45000;
    const NUM_STREAMS = 7;
    const WORKGROUP_SIZE = 64;

    const canvas = document.getElementById('hero-canvas');
    const statusDot = document.getElementById('status-dot');
    const statusText = document.getElementById('status-text');
    const particleCountEl = document.getElementById('particle-count');
    const fpsDisplayEl = document.getElementById('fps-display');

    async function initWebGPU() {
        if (!navigator.gpu) {
            statusDot.classList.add('inactive');
            statusText.classList.add('inactive');
            statusText.textContent = 'WebGPU Not Supported';
            return false;
        }

        let adapter;
        try {
            adapter = await navigator.gpu.requestAdapter({ powerPreference: 'high-performance' });
        } catch (e) {
            statusDot.classList.add('inactive');
            statusText.classList.add('inactive');
            statusText.textContent = 'WebGPU Error';
            return false;
        }

        if (!adapter) {
            statusDot.classList.add('inactive');
            statusText.classList.add('inactive');
            statusText.textContent = 'No GPU Adapter';
            return false;
        }

        let device;
        try {
            device = await adapter.requestDevice();
        } catch (e) {
            statusDot.classList.add('inactive');
            statusText.classList.add('inactive');
            statusText.textContent = 'Device Error';
            return false;
        }

        const context = canvas.getContext('webgpu');
        if (!context) {
            statusDot.classList.add('inactive');
            statusText.classList.add('inactive');
            statusText.textContent = 'No WebGPU Context';
            return false;
        }

        const format = navigator.gpu.getPreferredCanvasFormat();

        statusText.textContent = 'WebGPU Active';
        particleCountEl.textContent = NUM_PARTICLES.toLocaleString();

        function resize() {
            const rect = canvas.getBoundingClientRect();
            const dpr = Math.min(window.devicePixelRatio, 2);
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            context.configure({ device, format, alphaMode: 'premultiplied' });
        }
        resize();
        window.addEventListener('resize', resize);

        const computeCode = `
            struct Particle {
                pos: vec2f,
                vel: vec2f,
                life: f32,
                size: f32,
                stream: f32,
                seed: f32,
            }

            struct Uniforms {
                time: f32,
                deltaTime: f32,
                mouseX: f32,
                mouseY: f32,
            }

            @group(0) @binding(0) var<storage, read_write> particles: array<Particle>;
            @group(0) @binding(1) var<uniform> uniforms: Uniforms;

            fn rand(seed: f32) -> f32 {
                return fract(sin(seed * 12.9898) * 43758.5453);
            }
            
            fn noise(p: vec2f) -> f32 {
                let i = floor(p);
                let f = fract(p);
                let u = f * f * (3.0 - 2.0 * f);
                let a = rand(i.x + i.y * 57.0);
                let b = rand(i.x + 1.0 + i.y * 57.0);
                let c = rand(i.x + (i.y + 1.0) * 57.0);
                let d = rand(i.x + 1.0 + (i.y + 1.0) * 57.0);
                return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
            }

            @compute @workgroup_size(${WORKGROUP_SIZE})
            fn main(@builtin(global_invocation_id) id: vec3u) {
                let i = id.x;
                if (i >= ${NUM_PARTICLES}u) { return; }

                var p = particles[i];
                
                let n1 = noise(vec2f(p.pos.x * 2.0, p.pos.y + uniforms.time * 0.08)) - 0.5;
                p.vel.x += n1 * 0.00006;
                
                let upSpeed = 0.00014 + p.size * 0.00006;
                p.vel.y += upSpeed;
                
                let streamCenter = (p.stream - 0.5) * 0.7;
                p.vel.x += (streamCenter - p.pos.x) * 0.0018;
                
                let mousePos = vec2f(uniforms.mouseX, uniforms.mouseY);
                let toMouse = p.pos - mousePos;
                let dist = length(toMouse);
                
                if (dist < 0.18 && dist > 0.001) {
                    let burstAngle = rand(p.seed + uniforms.time * 10.0) * 6.28318;
                    let burstDir = vec2f(cos(burstAngle), sin(burstAngle));
                    let force = (0.18 - dist) / 0.18;
                    let burstStrength = force * force * 0.018;
                    let outward = normalize(toMouse);
                    let finalDir = normalize(outward * 0.25 + burstDir * 0.75);
                    p.vel += finalDir * burstStrength;
                    p.size *= 0.96;
                    p.life -= 0.025;
                }
                
                p.pos += p.vel;
                p.vel *= 0.93;
                
                let h = (p.pos.y + 1.0) * 0.5;
                let basLife = 1.0 - h * h * 0.5;
                if (h < 0.1) {
                    p.life = min(p.life, basLife * h * 10.0);
                } else {
                    p.life = min(p.life + 0.006, basLife);
                }
                
                if (p.pos.y > 1.0 || p.life < 0.05 || abs(p.pos.x) > 0.75 || p.size < 0.1) {
                    let s = p.seed + uniforms.time * 0.1;
                    p.stream = floor(rand(s) * ${NUM_STREAMS}.0) / ${NUM_STREAMS}.0;
                    let sc = (p.stream - 0.5) * 0.7;
                    
                    p.pos.x = sc + (rand(s * 2.0) - 0.5) * 0.04;
                    p.pos.y = -0.95 - rand(s * 3.0) * 0.1;
                    p.vel = vec2f(0.0, 0.00006);
                    p.life = 0.15;
                    
                    let sr = rand(s * 6.0);
                    if (sr < 0.4) { p.size = 0.2 + sr * 0.5; }
                    else if (sr < 0.75) { p.size = 0.4 + (sr - 0.4) * 1.0; }
                    else if (sr < 0.92) { p.size = 0.7 + (sr - 0.75) * 1.2; }
                    else { p.size = 1.0 + (sr - 0.92) * 2.0; }
                    p.seed = rand(s * 7.0) * 1000.0;
                }
                
                particles[i] = p;
            }
        `;

        const renderCode = `
            struct Particle {
                pos: vec2f,
                vel: vec2f,
                life: f32,
                size: f32,
                stream: f32,
                seed: f32,
            }

            struct Uniforms {
                aspectRatio: f32,
                time: f32,
            }

            struct VSOut {
                @builtin(position) pos: vec4f,
                @location(0) uv: vec2f,
                @location(1) color: vec4f,
                @location(2) velocity: vec2f,
            }

            @group(0) @binding(0) var<storage, read> particles: array<Particle>;
            @group(0) @binding(1) var<uniform> uniforms: Uniforms;

            @vertex
            fn vs(@builtin(vertex_index) vi: u32, @builtin(instance_index) ii: u32) -> VSOut {
                let p = particles[ii];
                
                var quad = array<vec2f, 6>(
                    vec2f(-1, -1), vec2f(1, -1), vec2f(-1, 1),
                    vec2f(-1, 1), vec2f(1, -1), vec2f(1, 1)
                );
                
                let size = p.size * 0.010 * (0.5 + p.life * 0.5);
                var pos = p.pos + quad[vi] * size;
                pos.x /= uniforms.aspectRatio;
                
                let h = (p.pos.y + 1.0) * 0.5;
                var col: vec3f;
                if (h < 0.3) {
                    col = mix(vec3f(0.18, 0.48, 0.58), vec3f(0.32, 0.62, 0.72), h / 0.3);
                } else if (h < 0.7) {
                    col = mix(vec3f(0.32, 0.62, 0.72), vec3f(0.52, 0.78, 0.88), (h - 0.3) / 0.4);
                } else {
                    col = mix(vec3f(0.52, 0.78, 0.88), vec3f(0.88, 0.78, 0.48), (h - 0.7) / 0.3);
                }
                
                var out: VSOut;
                out.pos = vec4f(pos, 0.0, 1.0);
                out.uv = quad[vi] * 0.5 + 0.5;
                out.color = vec4f(col, p.life * 0.85);
                out.velocity = p.vel;
                return out;
            }

            @fragment
            fn fs(in: VSOut) -> @location(0) vec4f {
                var uv = in.uv;
                let speed = length(in.velocity);
                
                // More pronounced stretching for teardrop shape
                let stretch = 1.0 + speed * 80.0;
                uv.y = 0.5 + (uv.y - 0.5) / max(stretch * 0.6, 1.0);
                
                // Offset center for teardrop (bulge at bottom)
                let teardropOffset = vec2f(0.5, 0.45 + speed * 2.0);
                let d = length(uv - teardropOffset) * 2.0;
                
                // Softer droplet edge
                let droplet = smoothstep(1.0, 0.5, d);
                
                // Enhanced water-like highlights (specular reflections)
                let highlight1 = smoothstep(0.25, 0.0, length(in.uv - vec2f(0.38, 0.32))) * 0.7;
                let highlight2 = smoothstep(0.15, 0.0, length(in.uv - vec2f(0.55, 0.35))) * 0.35;
                let highlight3 = smoothstep(0.08, 0.0, length(in.uv - vec2f(0.62, 0.40))) * 0.2;
                
                // Rim lighting for water surface tension look
                let rim = smoothstep(0.4, 0.9, d) * 0.3;
                
                // Soft inner glow
                let glow = exp(-d * d * 3.0) * 0.15;
                
                // Refraction-like color shift at edges
                let edgeShift = smoothstep(0.3, 0.8, d) * 0.15;
                
                let finalAlpha = (droplet + glow) * in.color.a;
                var finalColor = in.color.rgb * (1.0 - rim + edgeShift);
                finalColor += vec3f(highlight1 + highlight2 + highlight3);
                
                if (finalAlpha < 0.015) { discard; }
                
                return vec4f(finalColor * droplet + in.color.rgb * glow * 0.5, finalAlpha);
            }
        `;

        const streamCode = `
            struct Uniforms { aspectRatio: f32, time: f32, }

            @group(0) @binding(0) var<uniform> uniforms: Uniforms;

            struct VSOut {
                @builtin(position) pos: vec4f,
                @location(0) uv: vec2f,
            }

            @vertex
            fn vs(@builtin(vertex_index) vi: u32) -> VSOut {
                var quad = array<vec2f, 6>(
                    vec2f(-1, -1), vec2f(1, -1), vec2f(-1, 1),
                    vec2f(-1, 1), vec2f(1, -1), vec2f(1, 1)
                );
                var out: VSOut;
                out.pos = vec4f(quad[vi], 0.0, 1.0);
                out.uv = quad[vi] * 0.5 + 0.5;
                return out;
            }

            @fragment
            fn fs(in: VSOut) -> @location(0) vec4f {
                let x = in.uv.x;
                let y = in.uv.y;
                var col = vec3f(0.0);
                
                for (var i = 0.0; i < ${NUM_STREAMS}.0; i += 1.0) {
                    let streamX = 0.5 + (i - ${NUM_STREAMS}.0 * 0.5 + 0.5) * 0.05;
                    let dist = abs(x - streamX);
                    
                    let line = smoothstep(0.0012, 0.0, dist) * 0.08;
                    let glow = smoothstep(0.015, 0.0, dist) * 0.03;
                    let vertFade = sin(y * 3.14159) * 0.65 + 0.35;
                    
                    let dotPhase = fract(uniforms.time * 0.045 + i * 0.1);
                    let dotY = fract(dotPhase + y * 0.85);
                    let dotFade = smoothstep(0.0, 0.2, dotY) * smoothstep(1.0, 0.8, dotY);
                    let dotBright = smoothstep(0.006, 0.0, dist) * dotFade * 0.12;
                    
                    col += vec3f(0.16, 0.42, 0.52) * (line + glow + dotBright) * vertFade;
                }
                
                return vec4f(col, 1.0);
            }
        `;

        const computeShader = device.createShaderModule({ code: computeCode });
        const renderShader = device.createShaderModule({ code: renderCode });
        const streamShader = device.createShaderModule({ code: streamCode });

        const particleData = new Float32Array(NUM_PARTICLES * 8);
        for (let i = 0; i < NUM_PARTICLES; i++) {
            const idx = i * 8;
            const stream = Math.floor(Math.random() * NUM_STREAMS) / NUM_STREAMS;
            const streamCenter = (stream - 0.5) * 0.7;
            const sr = Math.random();
            let size = sr < 0.4 ? 0.2 + sr * 0.5 : sr < 0.75 ? 0.4 + (sr - 0.4) * 1.0 : sr < 0.92 ? 0.7 + (sr - 0.75) * 1.2 : 1.0 + (sr - 0.92) * 2.0;
            
            particleData[idx] = streamCenter + (Math.random() - 0.5) * 0.04;
            particleData[idx + 1] = -0.95 + Math.random() * 1.9;
            particleData[idx + 2] = 0;
            particleData[idx + 3] = 0.00006;
            particleData[idx + 4] = Math.random();
            particleData[idx + 5] = size;
            particleData[idx + 6] = stream;
            particleData[idx + 7] = Math.random() * 1000;
        }

        const particleBuffer = device.createBuffer({
            size: particleData.byteLength,
            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
        });
        device.queue.writeBuffer(particleBuffer, 0, particleData);

        const computeUniformBuffer = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
        const renderUniformBuffer = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });

        const computePipeline = device.createComputePipeline({
            layout: 'auto',
            compute: { module: computeShader, entryPoint: 'main' }
        });

        const blendState = {
            color: { srcFactor: 'src-alpha', dstFactor: 'one', operation: 'add' },
            alpha: { srcFactor: 'one', dstFactor: 'one', operation: 'add' }
        };

        const streamPipeline = device.createRenderPipeline({
            layout: 'auto',
            vertex: { module: streamShader, entryPoint: 'vs' },
            fragment: { module: streamShader, entryPoint: 'fs', targets: [{ format, blend: blendState }] },
            primitive: { topology: 'triangle-list' }
        });

        const renderPipeline = device.createRenderPipeline({
            layout: 'auto',
            vertex: { module: renderShader, entryPoint: 'vs' },
            fragment: { module: renderShader, entryPoint: 'fs', targets: [{ format, blend: blendState }] },
            primitive: { topology: 'triangle-list' }
        });

        const computeBindGroup = device.createBindGroup({
            layout: computePipeline.getBindGroupLayout(0),
            entries: [
                { binding: 0, resource: { buffer: particleBuffer } },
                { binding: 1, resource: { buffer: computeUniformBuffer } }
            ]
        });

        const streamBindGroup = device.createBindGroup({
            layout: streamPipeline.getBindGroupLayout(0),
            entries: [{ binding: 0, resource: { buffer: renderUniformBuffer } }]
        });

        const renderBindGroup = device.createBindGroup({
            layout: renderPipeline.getBindGroupLayout(0),
            entries: [
                { binding: 0, resource: { buffer: particleBuffer } },
                { binding: 1, resource: { buffer: renderUniformBuffer } }
            ]
        });

        let mouseX = 0, mouseY = 0;
        const hero = document.querySelector('.hero');
        hero.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            mouseX = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            mouseY = -(((e.clientY - rect.top) / rect.height) * 2 - 1);
        });

        let lastTime = performance.now();
        let frameCount = 0;
        let fpsUpdateTime = performance.now();

        function frame(time) {
            const dt = Math.min((time - lastTime) / 1000, 0.1);
            lastTime = time;
            
            frameCount++;
            if (time - fpsUpdateTime >= 500) {
                const fps = Math.round(frameCount * 1000 / (time - fpsUpdateTime));
                fpsDisplayEl.textContent = fps;
                frameCount = 0;
                fpsUpdateTime = time;
            }

            const aspect = canvas.width / canvas.height;

            device.queue.writeBuffer(computeUniformBuffer, 0, new Float32Array([time / 1000, dt, mouseX * aspect, mouseY]));
            device.queue.writeBuffer(renderUniformBuffer, 0, new Float32Array([aspect, time / 1000, 0, 0]));

            const encoder = device.createCommandEncoder();

            const computePass = encoder.beginComputePass();
            computePass.setPipeline(computePipeline);
            computePass.setBindGroup(0, computeBindGroup);
            computePass.dispatchWorkgroups(Math.ceil(NUM_PARTICLES / WORKGROUP_SIZE));
            computePass.end();

            const renderPass = encoder.beginRenderPass({
                colorAttachments: [{
                    view: context.getCurrentTexture().createView(),
                    clearValue: { r: 0.02, g: 0.04, b: 0.07, a: 1 },
                    loadOp: 'clear',
                    storeOp: 'store'
                }]
            });
            
            renderPass.setPipeline(streamPipeline);
            renderPass.setBindGroup(0, streamBindGroup);
            renderPass.draw(6);
            
            renderPass.setPipeline(renderPipeline);
            renderPass.setBindGroup(0, renderBindGroup);
            renderPass.draw(6, NUM_PARTICLES);
            
            renderPass.end();
            device.queue.submit([encoder.finish()]);

            requestAnimationFrame(frame);
        }

        requestAnimationFrame(frame);
        return true;
    }

    initWebGPU().catch(err => {
        console.error('WebGPU Error:', err);
        statusDot.classList.add('inactive');
        statusText.classList.add('inactive');
        statusText.textContent = 'WebGPU Error';
    });

    const observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
            if (entry.isIntersecting) {
                entry.target.style.opacity = '1';
                entry.target.style.transform = 'translateX(0) translateY(0)';
            }
        });
    }, { threshold: 0.2 });

    document.querySelectorAll('.dogma-card').forEach((card, i) => {
        card.style.opacity = '0';
        card.style.transform = 'translateX(-30px)';
        card.style.transition = `all 0.6s ease ${i * 0.1}s`;
        observer.observe(card);
    });

    document.querySelectorAll('.stat-card').forEach((card, i) => {
        card.style.opacity = '0';
        card.style.transform = 'translateY(30px)';
        card.style.transition = `all 0.5s ease ${i * 0.08}s`;
        observer.observe(card);
    });
    </script>
</body>
</html>
